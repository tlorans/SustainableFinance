<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Scoring System · Julia for Sustainable Finance</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><script src="../../../copy.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Julia for Sustainable Finance</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Introduction to Optimization</span><ul><li><a class="tocitem" href="../../Introduction to Optimization/bisection_algorithm/">Bisection Algorithm</a></li><li><a class="tocitem" href="../../Introduction to Optimization/newton_method/">Newton&#39;s Method</a></li></ul></li><li><span class="tocitem">Introduction to Portfolio Optimization</span><ul><li><a class="tocitem" href="../../Portfolio Optimization/markowitz_framework/">The Markowitz framework</a></li></ul></li><li><span class="tocitem">ESG Investing</span><ul><li class="is-active"><a class="tocitem" href>Scoring System</a><ul class="internal"><li><a class="tocitem" href="#Normalizing-Scores"><span>Normalizing Scores</span></a></li><li><a class="tocitem" href="#Scoring-Tree"><span>Scoring Tree</span></a></li></ul></li><li><a class="tocitem" href="../qp_problem_for_tilting/">QP Problem for Tilting</a></li><li><a class="tocitem" href="../qp_problem_for_enhanced_esg/">QP Problem for Enhanced ESG Score</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">ESG Investing</a></li><li class="is-active"><a href>Scoring System</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Scoring System</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/tlorans/SustainableFinance/blob/master/docs/src/ESG Investing/scoring_system.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Scoring-System"><a class="docs-heading-anchor" href="#Scoring-System">Scoring System</a><a id="Scoring-System-1"></a><a class="docs-heading-anchor-permalink" href="#Scoring-System" title="Permalink"></a></h1><ul><li>Most of ESG scoring systems are based on scoring trees. </li><li>Raw data are normalised in order to obtain features <span>$X_1,...,X_m$</span></li><li>Features <span>$X_1,...,X_m$</span> are aggregated to obtain sub-scores <span>$s_1,...,s_n$</span>:</li></ul><p class="math-container">\[s_i = \sum_{j=1}^m \omega_{i,j}^{(1)}X_j\]</p><ul><li>Sub-scores <span>$s_1,...,s_n$</span> are aggregated to obtain the final score <span>$s$</span>:</li></ul><p class="math-container">\[s_i = \sum_{i=1}^n \omega_i^{(2)}s_i\]</p><p>This two-level structure can be extended to multi-level tree structures.</p><p>Let&#39;s implement the first stage of our scoring system.</p><p>First, we create a struct <code>Variable</code>, with two examples variables:</p><pre><code class="language-julia hljs">Base.@kwdef mutable struct Variable
    X::Vector{Float64}
    name::String 
end

X₁ = Variable(X = [94.0, 38.6, 30.6, 74.4, 97.1, 57.1, 132.4, 92.5, 64.9], name = &quot;X₁&quot;) 

X₂ = Variable(X = [-0.03, -0.0550, 0.056, -0.013, -0.168, -0.035, 0.0850, -0.0910, -0.0460], name = &quot;X₂&quot;)</code></pre><p>Let&#39;s also extend the functionality of <code>PrettyTables.jl</code> to support our new <code>Variable</code> struct:</p><pre><code class="language-julia hljs">using PrettyTables


function PrettyTables.pretty_table(X::Vector{Variable})
    x = reduce(hcat,[X[i].X for i in eachindex(X)])
    X_names = reduce(vcat,[X[i].name for i in eachindex(X)])
    return pretty_table(x, header = X_names)
end

pretty_table([X₁, X₂])</code></pre><p>This prints a nice table in the <code>REPL</code>:</p><pre><code class="nohighlight hljs">┌───────┬────────┐
│    X₁ │     X₂ │
├───────┼────────┤
│  30.6 │ -0.168 │
│  38.6 │ -0.091 │
│  57.1 │ -0.055 │
│  64.9 │ -0.046 │
│  74.4 │ -0.035 │
│  92.5 │  -0.03 │
│  94.0 │ -0.013 │
│  97.1 │  0.056 │
│ 132.4 │  0.085 │
└───────┴────────┘</code></pre><p>Now, the question is: how can we aggregate <span>$X_1$</span> and <span>$X_2$</span> to create a synthetic score? </p><p>We need to normalize the features <span>$X_1, ..., X_n$</span>!</p><h2 id="Normalizing-Scores"><a class="docs-heading-anchor" href="#Normalizing-Scores">Normalizing Scores</a><a id="Normalizing-Scores-1"></a><a class="docs-heading-anchor-permalink" href="#Normalizing-Scores" title="Permalink"></a></h2><p>Once raw data have been normalized in order to facilitate the comparison (ie. absolute carbon emissions amount transformed to carbon intensity for example), resulting features <span>$X_1, ..., X_m$</span> need to be normalized to facilitate the aggregation process.</p><p>Several normalization approches exist:</p><ul><li>q-score normalization:<ul><li>0-1 normalization: <span>$q_i \in [0,1]$</span></li><li>0-10 normalization: <span>$q_i \in [0,10]$</span></li><li>0-100 normalization: <span>$q_i \in [0,100]$</span></li></ul></li></ul><p class="math-container">\[q_i = \hat F(x_i)\]</p><p>Where <span>$\hat F$</span> is the empirical probability distribution.</p><ul><li>z-score normalization:</li></ul><p class="math-container">\[z_i = \frac{x_i - \hat\mu(X)}{\hat\sigma(X)}\]</p><p>To do so, let&#39;s implement a <code>Score</code> struct and a <code>ScoringSystem</code> struct. </p><pre><code class="language-julia hljs">Base.@kwdef mutable struct Score
    S::Vector{Float64}} # resulting score
    name::String
end


using Graphs # import for the directed graph
using GraphPlot # import for the directed graph
import Cairo, Fontconfig # import for the directed graph

Base.@kwdef mutable struct ScoringSystem
    X::Vector{Variable}
    S::Union{Nothing, Vector{Score}} = nothing # the vector of subscores
    ω::Union{Nothing, Vector{Float64}} = nothing # the vector of weights
    graph::Union{Nothing,SimpleDiGraph} = nothing # directed graph representing the scoring tree 
    score::Union{Nothing,Score} = nothing # the vector of aggregated score
end

our_scoring = ScoringSystem(X = [X₁,X₂])</code></pre><p>The purpose of the struct <code>Score</code> is to facilitate the interface between our <code>Variable</code>, our future functions for normalization, and the result (the <code>Score</code>). The purpose of the <code>ScoringSystem</code> struct is to regroup / organize our little scoring system.</p><h3 id="q-score"><a class="docs-heading-anchor" href="#q-score">q-score</a><a id="q-score-1"></a><a class="docs-heading-anchor-permalink" href="#q-score" title="Permalink"></a></h3><p>Let <span>$x_1, .., x_n$</span> be the sample. We have:</p><p class="math-container">\[q_i = \hat{F}(x_i) = Pr(X \leq x_i) = \frac{\#(x_j \leq x_i)}{n_q}\]</p><p>We can use two normalization factors:</p><ul><li><p class="math-container">\[n_q = n\]</p></li><li><p class="math-container">\[n_q = n + 1\]</p></li></ul><p>Let&#39;s implement this in Julia:</p><pre><code class="language-julia hljs">using Plots # to print the ecdf

function q_score(X::Variable; scale = 100, get_plot = true)::Score 
    # the number of observations
    n = length(X.X)
    # we normalize the number of observations less or equal to each observation by n + 1 (the second normalization factor)
    q = [length(filter(x -&gt; x &lt;= i, X.X))/(n+1) for i in X.X] .* scale
    s = Score(S = q, name = string(&quot;q-score &quot;,X.name))
    # we print the ecdf of the variable to get a sense of q-score normalization
    if get_plot
        display(plot(sort(X.X), (1:n)./n * 100, 
            xlabel = X.name, ylabel = s.name,
            title = &quot;q-score normalization&quot;, label = &quot;&quot;))
    end
    return s
end

# just the vector version of the function
function q_score(X::Vector{Variable}; scale = 100, get_plot = true)::Vector{Score}
    s = []
    for i in eachindex(X)
        push!(s, q_score(X[i]; scale, get_plot))
    end 
    return s 
end

# and finally the version applied to our scoring system
function q_score!(s::ScoringSystem; scale = 100, get_plot = true)::ScoringSystem
    s.S = q_score(s.X; scale, get_plot)
    return s
end

q_score!(our_scoring)</code></pre><p>The resulting scoring functions looks like the graphs below: <img src="../x_1_q_score.png" alt="&quot;ecdf&quot;"/> <img src="../x_2_q_score.png" alt="&quot;ecdf&quot;"/></p><p>Now let&#39;s again extend the <code>PrettyTables.jl</code> functionality to be applied on our <code>ScoringSystem</code>:</p><pre><code class="language-julia hljs">
function PrettyTables.pretty_table(s::ScoringSystem)
    X = reduce(hcat,[s.X[i].X for i in eachindex(s.X)])
    S = reduce(hcat,[s.S[i].S for i in eachindex(s.S)])
    X_names = reduce(vcat,[s.X[i].name for i in eachindex(s.X)])
    S_names = reduce(vcat,[s.S[i].name for i in eachindex(s.S)])
    return pretty_table(hcat(X,S), header = vcat(X_names, S_names))
end

pretty_table(our_scoring)</code></pre><p>We get the following table:</p><pre><code class="nohighlight hljs">┌───────┬────────┬────────────┬────────────┐
│    X₁ │     X₂ │ q-score X₁ │ q-score X₂ │
├───────┼────────┼────────────┼────────────┤
│  94.0 │  -0.03 │       70.0 │       60.0 │
│  38.6 │ -0.055 │       20.0 │       30.0 │
│  30.6 │  0.056 │       10.0 │       80.0 │
│  74.4 │ -0.013 │       50.0 │       70.0 │
│  97.1 │ -0.168 │       80.0 │       10.0 │
│  57.1 │ -0.035 │       30.0 │       50.0 │
│ 132.4 │  0.085 │       90.0 │       90.0 │
│  92.5 │ -0.091 │       60.0 │       20.0 │
│  64.9 │ -0.046 │       40.0 │       40.0 │
└───────┴────────┴────────────┴────────────┘</code></pre><h3 id="z-score"><a class="docs-heading-anchor" href="#z-score">z-score</a><a id="z-score-1"></a><a class="docs-heading-anchor-permalink" href="#z-score" title="Permalink"></a></h3><p>Another normalization method can be the <span>$z$</span>-score:</p><pre><code class="language-julia hljs">using Statistics # to load the mean and std functions

# z-score normalization for a unique variable
function z_score(X::Variable; get_plot = true)::Score 
    μ = mean(X.X)
    σ = std(X.X)
    z = [(i - μ) / σ for i in X.X]
    s = Score(S = z, name = string(&quot;z-score &quot;,X.name))
    if get_plot
        display(plot(sort(X.X), sort(s.S), 
            xlabel = X.name, ylabel = s.name,
            title = &quot;z-score normalization&quot;, label = &quot;&quot;))
    end
    return s
end

# vector version
function z_score(X::Vector{Variable}; get_plot = true)::Vector{Score}
    s = []
    for i in eachindex(X)
        push!(s, z_score(X[i]; get_plot))
    end 
    return s 
end

# version to be applied to our scoring system
function z_score!(s::ScoringSystem; get_plot = true)::ScoringSystem
    s.S = z_score(s.X; get_plot)
    return s
end

z_score!(our_scoring)</code></pre><p><img src="../x_1_z_score.png" alt="&quot;z-score&quot;"/> <img src="../x_2_z_score.png" alt="&quot;z-score&quot;"/></p><pre><code class="nohighlight hljs">┌───────┬────────┬────────────┬────────────┐
│    X₁ │     X₂ │ z-score X₁ │ z-score X₂ │
├───────┼────────┼────────────┼────────────┤
│  94.0 │  -0.03 │   0.571788 │  0.0402241 │
│  38.6 │ -0.055 │   -1.16236 │  -0.294977 │
│  30.6 │  0.056 │   -1.41277 │    1.19331 │
│  74.4 │ -0.013 │ -0.0417363 │   0.268161 │
│  97.1 │ -0.168 │   0.668825 │   -1.81008 │
│  57.1 │ -0.035 │  -0.583265 │ -0.0268161 │
│ 132.4 │  0.085 │    1.77379 │    1.58215 │
│  92.5 │ -0.091 │   0.524834 │  -0.777666 │
│  64.9 │ -0.046 │  -0.339108 │  -0.174304 │
└───────┴────────┴────────────┴────────────┘</code></pre><h2 id="Scoring-Tree"><a class="docs-heading-anchor" href="#Scoring-Tree">Scoring Tree</a><a id="Scoring-Tree-1"></a><a class="docs-heading-anchor-permalink" href="#Scoring-Tree" title="Permalink"></a></h2><p>As mentioned previously, most ESG scoring systems are based on scoring trees. Our example is a simple two-level tree structure. Let&#39;s represent it with a directed graph:</p><pre><code class="language-julia hljs">function get_scoring_tree!(s::ScoringSystem)::ScoringSystem
    n = length(s.S) # number of subscores
    G = Graphs.SimpleDiGraph(n+1) # we add + 1 to n because we need to take into account the score (aggregated)
    for i in 2:n+1 
        add_edge!(G,i, 1)
    end 
    # plot the graph 
    nodelabel = vcat([&quot;s&quot;],[s.S[i].name for i in eachindex(s.S)])
    display(gplot(G, nodelabel = nodelabel))
    s.graph = G
    return s
end

get_scoring_tree!(our_scoring)</code></pre><p><img src="../scoring_tree.png" alt="&quot;scoring_tree&quot;"/></p><p>Finally, let&#39;s compute the aggregated score with <span>$\omega_1 = 0.3$</span> and <span>$\omega_2 = 0.7$</span>:</p><pre><code class="language-julia hljs">
function get_aggregate_score!(s::ScoringSystem)::ScoringSystem
# just the weighted sum
    s.score = Score(S = sum([s.S[i].S * s.ω[i] for i in eachindex(s.ω)]),
                    name = &quot;Aggregate score&quot;)

    # will print the result in table format
    pretty_table(s.score.S, header = [s.score.name])
    return s
end

our_scoring.ω = [0.3, 0.7] # our weights vector

get_aggregate_score!(our_scoring)</code></pre><pre><code class="nohighlight hljs">┌─────────────────┐
│ Aggregate score │
├─────────────────┤
│        0.199693 │
│       -0.555191 │
│        0.411488 │
│        0.175192 │
│        -1.06641 │
│       -0.193751 │
│         1.63964 │
│       -0.386916 │
│       -0.223745 │
└─────────────────┘</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../Portfolio Optimization/markowitz_framework/">« The Markowitz framework</a><a class="docs-footer-nextpage" href="../qp_problem_for_tilting/">QP Problem for Tilting »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.12 on <span class="colophon-date" title="Tuesday 15 February 2022 07:27">Tuesday 15 February 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
