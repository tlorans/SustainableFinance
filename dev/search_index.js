var documenterSearchIndex = {"docs":
[{"location":"ESG Investing/scoring_system/#Scoring-System","page":"Scoring System","title":"Scoring System","text":"","category":"section"},{"location":"ESG Investing/scoring_system/","page":"Scoring System","title":"Scoring System","text":"Most of ESG scoring systems are based on scoring trees. \nRaw data are normalised in order to obtain features X_1X_m\nFeatures X_1X_m are aggregated to obtain sub-scores s_1s_n:","category":"page"},{"location":"ESG Investing/scoring_system/","page":"Scoring System","title":"Scoring System","text":"s_i = sum_j=1^m omega_ij^(1)X_j","category":"page"},{"location":"ESG Investing/scoring_system/","page":"Scoring System","title":"Scoring System","text":"Sub-scores s_1s_n are aggregated to obtain the final score s:","category":"page"},{"location":"ESG Investing/scoring_system/","page":"Scoring System","title":"Scoring System","text":"s_i = sum_i=1^n omega_i^(2)s_i","category":"page"},{"location":"ESG Investing/scoring_system/","page":"Scoring System","title":"Scoring System","text":"This two-level structure can be extended to multi-level tree structures.","category":"page"},{"location":"ESG Investing/scoring_system/","page":"Scoring System","title":"Scoring System","text":"Let's implement the first stage of our scoring system.","category":"page"},{"location":"ESG Investing/scoring_system/","page":"Scoring System","title":"Scoring System","text":"First, we create a struct Variable, with two examples variables:","category":"page"},{"location":"ESG Investing/scoring_system/","page":"Scoring System","title":"Scoring System","text":"Base.@kwdef mutable struct Variable\n    X::Vector{Float64}\n    name::String \nend\n\nX₁ = Variable(X = [94.0, 38.6, 30.6, 74.4, 97.1, 57.1, 132.4, 92.5, 64.9], name = \"X₁\") \n\nX₂ = Variable(X = [-0.03, -0.0550, 0.056, -0.013, -0.168, -0.035, 0.0850, -0.0910, -0.0460], name = \"X₂\")","category":"page"},{"location":"ESG Investing/scoring_system/","page":"Scoring System","title":"Scoring System","text":"Let's also extend the functionality of PrettyTables.jl to support our new Variable struct:","category":"page"},{"location":"ESG Investing/scoring_system/","page":"Scoring System","title":"Scoring System","text":"using PrettyTables\n\n\nfunction PrettyTables.pretty_table(X::Vector{Variable})\n    x = reduce(hcat,[X[i].X for i in eachindex(X)])\n    X_names = reduce(vcat,[X[i].name for i in eachindex(X)])\n    return pretty_table(x, header = X_names)\nend\n\npretty_table([X₁, X₂])","category":"page"},{"location":"ESG Investing/scoring_system/","page":"Scoring System","title":"Scoring System","text":"This prints a nice table in the REPL:","category":"page"},{"location":"ESG Investing/scoring_system/","page":"Scoring System","title":"Scoring System","text":"┌───────┬────────┐\n│    X₁ │     X₂ │\n├───────┼────────┤\n│  30.6 │ -0.168 │\n│  38.6 │ -0.091 │\n│  57.1 │ -0.055 │\n│  64.9 │ -0.046 │\n│  74.4 │ -0.035 │\n│  92.5 │  -0.03 │\n│  94.0 │ -0.013 │\n│  97.1 │  0.056 │\n│ 132.4 │  0.085 │\n└───────┴────────┘","category":"page"},{"location":"ESG Investing/scoring_system/","page":"Scoring System","title":"Scoring System","text":"Now, the question is: how can we aggregate X_1 and X_2 to create a synthetic score? ","category":"page"},{"location":"ESG Investing/scoring_system/","page":"Scoring System","title":"Scoring System","text":"We need to normalize the features X_1  X_n!","category":"page"},{"location":"ESG Investing/scoring_system/#Normalizing-Scores","page":"Scoring System","title":"Normalizing Scores","text":"","category":"section"},{"location":"ESG Investing/scoring_system/","page":"Scoring System","title":"Scoring System","text":"Once raw data have been normalized in order to facilitate the comparison (ie. absolute carbon emissions amount transformed to carbon intensity for example), resulting features X_1  X_m need to be normalized to facilitate the aggregation process.","category":"page"},{"location":"ESG Investing/scoring_system/","page":"Scoring System","title":"Scoring System","text":"Several normalization approches exist:","category":"page"},{"location":"ESG Investing/scoring_system/","page":"Scoring System","title":"Scoring System","text":"q-score normalization:\n0-1 normalization: q_i in 01\n0-10 normalization: q_i in 010\n0-100 normalization: q_i in 0100","category":"page"},{"location":"ESG Investing/scoring_system/","page":"Scoring System","title":"Scoring System","text":"q_i = hat F(x_i)","category":"page"},{"location":"ESG Investing/scoring_system/","page":"Scoring System","title":"Scoring System","text":"Where hat F is the empirical probability distribution.","category":"page"},{"location":"ESG Investing/scoring_system/","page":"Scoring System","title":"Scoring System","text":"z-score normalization:","category":"page"},{"location":"ESG Investing/scoring_system/","page":"Scoring System","title":"Scoring System","text":"z_i = fracx_i - hatmu(X)hatsigma(X)","category":"page"},{"location":"ESG Investing/scoring_system/","page":"Scoring System","title":"Scoring System","text":"To do so, let's implement a Score struct and a ScoringSystem struct. ","category":"page"},{"location":"ESG Investing/scoring_system/","page":"Scoring System","title":"Scoring System","text":"Base.@kwdef mutable struct Score\n    S::Vector{Float64}} # resulting score\n    name::String\nend\n\n\nusing Graphs # import for the directed graph\nusing GraphPlot # import for the directed graph\nimport Cairo, Fontconfig # import for the directed graph\n\nBase.@kwdef mutable struct ScoringSystem\n    X::Vector{Variable}\n    S::Union{Nothing, Vector{Score}} = nothing # the vector of subscores\n    ω::Union{Nothing, Vector{Float64}} = nothing # the vector of weights\n    graph::Union{Nothing,SimpleDiGraph} = nothing # directed graph representing the scoring tree \n    score::Union{Nothing,Score} = nothing # the vector of aggregated score\nend\n\nour_scoring = ScoringSystem(X = [X₁,X₂])","category":"page"},{"location":"ESG Investing/scoring_system/","page":"Scoring System","title":"Scoring System","text":"The purpose of the struct Score is to facilitate the interface between our Variable, our future functions for normalization, and the result (the Score). The purpose of the ScoringSystem struct is to regroup / organize our little scoring system.","category":"page"},{"location":"ESG Investing/scoring_system/#q-score","page":"Scoring System","title":"q-score","text":"","category":"section"},{"location":"ESG Investing/scoring_system/","page":"Scoring System","title":"Scoring System","text":"Let x_1  x_n be the sample. We have:","category":"page"},{"location":"ESG Investing/scoring_system/","page":"Scoring System","title":"Scoring System","text":"q_i = hatF(x_i) = Pr(X leq x_i) = frac(x_j leq x_i)n_q","category":"page"},{"location":"ESG Investing/scoring_system/","page":"Scoring System","title":"Scoring System","text":"We can use two normalization factors:","category":"page"},{"location":"ESG Investing/scoring_system/","page":"Scoring System","title":"Scoring System","text":"n_q = n\nn_q = n + 1","category":"page"},{"location":"ESG Investing/scoring_system/","page":"Scoring System","title":"Scoring System","text":"Let's implement this in Julia:","category":"page"},{"location":"ESG Investing/scoring_system/","page":"Scoring System","title":"Scoring System","text":"using Plots # to print the ecdf\n\nfunction q_score(X::Variable; scale = 100, get_plot = true)::Score \n    # the number of observations\n    n = length(X.X)\n    # we normalize the number of observations less or equal to each observation by n + 1 (the second normalization factor)\n    q = [length(filter(x -> x <= i, X.X))/(n+1) for i in X.X] .* scale\n    s = Score(S = q, name = string(\"q-score \",X.name))\n    # we print the ecdf of the variable to get a sense of q-score normalization\n    if get_plot\n        display(plot(sort(X.X), (1:n)./n * 100, \n            xlabel = X.name, ylabel = s.name,\n            title = \"q-score normalization\", label = \"\"))\n    end\n    return s\nend\n\n# just the vector version of the function\nfunction q_score(X::Vector{Variable}; scale = 100, get_plot = true)::Vector{Score}\n    s = []\n    for i in eachindex(X)\n        push!(s, q_score(X[i]; scale, get_plot))\n    end \n    return s \nend\n\n# and finally the version applied to our scoring system\nfunction q_score!(s::ScoringSystem; scale = 100, get_plot = true)::ScoringSystem\n    s.S = q_score(s.X; scale, get_plot)\n    return s\nend\n\nq_score!(our_scoring)","category":"page"},{"location":"ESG Investing/scoring_system/","page":"Scoring System","title":"Scoring System","text":"The resulting scoring functions looks like the graphs below: (Image: \"ecdf\") (Image: \"ecdf\")","category":"page"},{"location":"ESG Investing/scoring_system/","page":"Scoring System","title":"Scoring System","text":"Now let's again extend the PrettyTables.jl functionality to be applied on our ScoringSystem:","category":"page"},{"location":"ESG Investing/scoring_system/","page":"Scoring System","title":"Scoring System","text":"\nfunction PrettyTables.pretty_table(s::ScoringSystem)\n    X = reduce(hcat,[s.X[i].X for i in eachindex(s.X)])\n    S = reduce(hcat,[s.S[i].S for i in eachindex(s.S)])\n    X_names = reduce(vcat,[s.X[i].name for i in eachindex(s.X)])\n    S_names = reduce(vcat,[s.S[i].name for i in eachindex(s.S)])\n    return pretty_table(hcat(X,S), header = vcat(X_names, S_names))\nend\n\npretty_table(our_scoring)","category":"page"},{"location":"ESG Investing/scoring_system/","page":"Scoring System","title":"Scoring System","text":"We get the following table:","category":"page"},{"location":"ESG Investing/scoring_system/","page":"Scoring System","title":"Scoring System","text":"┌───────┬────────┬────────────┬────────────┐\n│    X₁ │     X₂ │ q-score X₁ │ q-score X₂ │\n├───────┼────────┼────────────┼────────────┤\n│  94.0 │  -0.03 │       70.0 │       60.0 │\n│  38.6 │ -0.055 │       20.0 │       30.0 │\n│  30.6 │  0.056 │       10.0 │       80.0 │\n│  74.4 │ -0.013 │       50.0 │       70.0 │\n│  97.1 │ -0.168 │       80.0 │       10.0 │\n│  57.1 │ -0.035 │       30.0 │       50.0 │\n│ 132.4 │  0.085 │       90.0 │       90.0 │\n│  92.5 │ -0.091 │       60.0 │       20.0 │\n│  64.9 │ -0.046 │       40.0 │       40.0 │\n└───────┴────────┴────────────┴────────────┘","category":"page"},{"location":"ESG Investing/scoring_system/#z-score","page":"Scoring System","title":"z-score","text":"","category":"section"},{"location":"ESG Investing/scoring_system/","page":"Scoring System","title":"Scoring System","text":"Another normalization method can be the z-score:","category":"page"},{"location":"ESG Investing/scoring_system/","page":"Scoring System","title":"Scoring System","text":"using Statistics # to load the mean and std functions\n\n# z-score normalization for a unique variable\nfunction z_score(X::Variable; get_plot = true)::Score \n    μ = mean(X.X)\n    σ = std(X.X)\n    z = [(i - μ) / σ for i in X.X]\n    s = Score(S = z, name = string(\"z-score \",X.name))\n    if get_plot\n        display(plot(sort(X.X), sort(s.S), \n            xlabel = X.name, ylabel = s.name,\n            title = \"z-score normalization\", label = \"\"))\n    end\n    return s\nend\n\n# vector version\nfunction z_score(X::Vector{Variable}; get_plot = true)::Vector{Score}\n    s = []\n    for i in eachindex(X)\n        push!(s, z_score(X[i]; get_plot))\n    end \n    return s \nend\n\n# version to be applied to our scoring system\nfunction z_score!(s::ScoringSystem; get_plot = true)::ScoringSystem\n    s.S = z_score(s.X; get_plot)\n    return s\nend\n\nz_score!(our_scoring)","category":"page"},{"location":"ESG Investing/scoring_system/","page":"Scoring System","title":"Scoring System","text":"(Image: \"z-score\") (Image: \"z-score\")","category":"page"},{"location":"ESG Investing/scoring_system/","page":"Scoring System","title":"Scoring System","text":"┌───────┬────────┬────────────┬────────────┐\n│    X₁ │     X₂ │ z-score X₁ │ z-score X₂ │\n├───────┼────────┼────────────┼────────────┤\n│  94.0 │  -0.03 │   0.571788 │  0.0402241 │\n│  38.6 │ -0.055 │   -1.16236 │  -0.294977 │\n│  30.6 │  0.056 │   -1.41277 │    1.19331 │\n│  74.4 │ -0.013 │ -0.0417363 │   0.268161 │\n│  97.1 │ -0.168 │   0.668825 │   -1.81008 │\n│  57.1 │ -0.035 │  -0.583265 │ -0.0268161 │\n│ 132.4 │  0.085 │    1.77379 │    1.58215 │\n│  92.5 │ -0.091 │   0.524834 │  -0.777666 │\n│  64.9 │ -0.046 │  -0.339108 │  -0.174304 │\n└───────┴────────┴────────────┴────────────┘","category":"page"},{"location":"ESG Investing/scoring_system/#Scoring-Tree","page":"Scoring System","title":"Scoring Tree","text":"","category":"section"},{"location":"ESG Investing/scoring_system/","page":"Scoring System","title":"Scoring System","text":"As mentioned previously, most ESG scoring systems are based on scoring trees. Our example is a simple two-level tree structure. Let's represent it with a directed graph:","category":"page"},{"location":"ESG Investing/scoring_system/","page":"Scoring System","title":"Scoring System","text":"function get_scoring_tree!(s::ScoringSystem)::ScoringSystem\n    n = length(s.S) # number of subscores\n    G = Graphs.SimpleDiGraph(n+1) # we add + 1 to n because we need to take into account the score (aggregated)\n    for i in 2:n+1 \n        add_edge!(G,i, 1)\n    end \n    # plot the graph \n    nodelabel = vcat([\"s\"],[s.S[i].name for i in eachindex(s.S)])\n    display(gplot(G, nodelabel = nodelabel))\n    s.graph = G\n    return s\nend\n\nget_scoring_tree!(our_scoring)","category":"page"},{"location":"ESG Investing/scoring_system/","page":"Scoring System","title":"Scoring System","text":"(Image: \"scoring_tree\")","category":"page"},{"location":"ESG Investing/scoring_system/","page":"Scoring System","title":"Scoring System","text":"Finally, let's compute the aggregated score with omega_1 = 03 and omega_2 = 07:","category":"page"},{"location":"ESG Investing/scoring_system/","page":"Scoring System","title":"Scoring System","text":"\nfunction get_aggregate_score!(s::ScoringSystem)::ScoringSystem\n# just the weighted sum\n    s.score = Score(S = sum([s.S[i].S * s.ω[i] for i in eachindex(s.ω)]),\n                    name = \"Aggregate score\")\n\n    # will print the result in table format\n    pretty_table(s.score.S, header = [s.score.name])\n    return s\nend\n\nour_scoring.ω = [0.3, 0.7] # our weights vector\n\nget_aggregate_score!(our_scoring)","category":"page"},{"location":"ESG Investing/scoring_system/","page":"Scoring System","title":"Scoring System","text":"┌─────────────────┐\n│ Aggregate score │\n├─────────────────┤\n│        0.199693 │\n│       -0.555191 │\n│        0.411488 │\n│        0.175192 │\n│        -1.06641 │\n│       -0.193751 │\n│         1.63964 │\n│       -0.386916 │\n│       -0.223745 │\n└─────────────────┘","category":"page"},{"location":"Portfolio Optimization/markowitz_framework/#The-Markowitz-framework","page":"The Markowitz framework","title":"The Markowitz framework","text":"","category":"section"},{"location":"Portfolio Optimization/markowitz_framework/#Portfolio-definition","page":"The Markowitz framework","title":"Portfolio definition","text":"","category":"section"},{"location":"Portfolio Optimization/markowitz_framework/","page":"The Markowitz framework","title":"The Markowitz framework","text":"We consider a universe of n assets\nThe vector of weights in the portfolio: ","category":"page"},{"location":"Portfolio Optimization/markowitz_framework/","page":"The Markowitz framework","title":"The Markowitz framework","text":"x = (x_1x_n)","category":"page"},{"location":"Portfolio Optimization/markowitz_framework/","page":"The Markowitz framework","title":"The Markowitz framework","text":"The portfolio is fuly invested:","category":"page"},{"location":"Portfolio Optimization/markowitz_framework/","page":"The Markowitz framework","title":"The Markowitz framework","text":"sum^n_i=1 x_i = 1_n^Tx = 1","category":"page"},{"location":"Portfolio Optimization/markowitz_framework/","page":"The Markowitz framework","title":"The Markowitz framework","text":"The vector of asset returns where R_i is the return of asset i","category":"page"},{"location":"Portfolio Optimization/markowitz_framework/","page":"The Markowitz framework","title":"The Markowitz framework","text":"R = (R_1R_n)","category":"page"},{"location":"Portfolio Optimization/markowitz_framework/","page":"The Markowitz framework","title":"The Markowitz framework","text":"The return of the portfolio is equal to:","category":"page"},{"location":"Portfolio Optimization/markowitz_framework/","page":"The Markowitz framework","title":"The Markowitz framework","text":"R(x) = sum^n_i=1x_iR_i = x^TR","category":"page"},{"location":"Portfolio Optimization/markowitz_framework/","page":"The Markowitz framework","title":"The Markowitz framework","text":"The vector of expected returns","category":"page"},{"location":"Portfolio Optimization/markowitz_framework/","page":"The Markowitz framework","title":"The Markowitz framework","text":"mu = ER","category":"page"},{"location":"Portfolio Optimization/markowitz_framework/","page":"The Markowitz framework","title":"The Markowitz framework","text":"The covariance matrix of asset returns:","category":"page"},{"location":"Portfolio Optimization/markowitz_framework/","page":"The Markowitz framework","title":"The Markowitz framework","text":"Sigma = E(R-mu)(R-mu)^T","category":"page"},{"location":"Portfolio Optimization/markowitz_framework/","page":"The Markowitz framework","title":"The Markowitz framework","text":"Let's implement a Portfolio struct to encode these first informations: ","category":"page"},{"location":"Portfolio Optimization/markowitz_framework/","page":"The Markowitz framework","title":"The Markowitz framework","text":"Base.@kwdef mutable struct Portfolio \n    μ::Vector{Float64} # the expected returns \n    σ::Vector{Float64} # volatiltiy\n    x::Vector{Float64} # Weights\n    C::Matrix # Correlation matrix\n    Σ::Union{Nothing, Matrix} = nothing # Covariance matrix\nend","category":"page"},{"location":"Portfolio Optimization/markowitz_framework/","page":"The Markowitz framework","title":"The Markowitz framework","text":"And create a first example:","category":"page"},{"location":"Portfolio Optimization/markowitz_framework/","page":"The Markowitz framework","title":"The Markowitz framework","text":"example_1 = Portfolio(μ = [0.05, 0.06, 0.08, 0.06],\n                        σ = [0.15, 0.20, 0.25, 0.30],\n                        x = [1/4 for i in 1:4], # just equally-weighted portfolio,\n                        C = [\n                            1 0.1 0.4 0.5\n                            0.1 1 0.7 0.4\n                            0.4 0.7 1 0.8\n                            0.5 0.4 0.8 1\n                            ])","category":"page"},{"location":"Portfolio Optimization/markowitz_framework/","page":"The Markowitz framework","title":"The Markowitz framework","text":"We extend the function pretty_table to be used with our Portfolio struct:","category":"page"},{"location":"Portfolio Optimization/markowitz_framework/","page":"The Markowitz framework","title":"The Markowitz framework","text":"using PrettyTables\n\nfunction PrettyTables.pretty_table(portf::Portfolio)\n    return pretty_table(reduce(hcat,[portf.μ, portf.σ, portf.x]), header = [\"μ\",\"σ\",\"x\"])\nend\n\n\npretty_table(example_1)","category":"page"},{"location":"Portfolio Optimization/markowitz_framework/","page":"The Markowitz framework","title":"The Markowitz framework","text":"We get:","category":"page"},{"location":"Portfolio Optimization/markowitz_framework/","page":"The Markowitz framework","title":"The Markowitz framework","text":"┌──────┬──────┬──────┐\n│    μ │    σ │    x │\n├──────┼──────┼──────┤\n│ 0.05 │ 0.15 │ 0.25 │\n│ 0.06 │  0.2 │ 0.25 │\n│ 0.08 │ 0.25 │ 0.25 │\n│ 0.06 │  0.3 │ 0.25 │\n└──────┴──────┴──────┘","category":"page"},{"location":"Portfolio Optimization/markowitz_framework/#Expected-return-and-volatility","page":"The Markowitz framework","title":"Expected return and volatility","text":"","category":"section"},{"location":"Portfolio Optimization/markowitz_framework/","page":"The Markowitz framework","title":"The Markowitz framework","text":"The expected return of the portfolio is:","category":"page"},{"location":"Portfolio Optimization/markowitz_framework/","page":"The Markowitz framework","title":"The Markowitz framework","text":"mu(x) = ER(x) = Ex^TR = x^T ER = x^T mu","category":"page"},{"location":"Portfolio Optimization/markowitz_framework/","page":"The Markowitz framework","title":"The Markowitz framework","text":"Implementing this in Julia:","category":"page"},{"location":"Portfolio Optimization/markowitz_framework/","page":"The Markowitz framework","title":"The Markowitz framework","text":"using LinearAlgebra\n\nfunction get_portfolio_return(portfolio::Portfolio)\n    return portfolio.x' * portfolio.μ # transpose of the vector of weights times the vector of expected reutnrs\nend\n\nget_portfolio_return(example_1)","category":"page"},{"location":"Portfolio Optimization/markowitz_framework/","page":"The Markowitz framework","title":"The Markowitz framework","text":"Whereas its variance is equal to:","category":"page"},{"location":"Portfolio Optimization/markowitz_framework/","page":"The Markowitz framework","title":"The Markowitz framework","text":"sigma^2(x) = E(R(x) - mu(x))(R(x) -mu(x))^T","category":"page"},{"location":"Portfolio Optimization/markowitz_framework/","page":"The Markowitz framework","title":"The Markowitz framework","text":"= E(x^T R - x^T mu)(x^T R - x^T mu)^T","category":"page"},{"location":"Portfolio Optimization/markowitz_framework/","page":"The Markowitz framework","title":"The Markowitz framework","text":"= Ex^T(R-mu)(R-mu)^Tx","category":"page"},{"location":"Portfolio Optimization/markowitz_framework/","page":"The Markowitz framework","title":"The Markowitz framework","text":"= x^T E(R-mu)(R-mu)^Tx","category":"page"},{"location":"Portfolio Optimization/markowitz_framework/","page":"The Markowitz framework","title":"The Markowitz framework","text":"= x^T Sigma x","category":"page"},{"location":"Portfolio Optimization/markowitz_framework/","page":"The Markowitz framework","title":"The Markowitz framework","text":"As a shorthand, because the correlation matrix C and standard deviation sigma will be given in most examples, we will deduce the covariance matrix Sigma based on the correlation matrix C and sigma, such as:","category":"page"},{"location":"Portfolio Optimization/markowitz_framework/","page":"The Markowitz framework","title":"The Markowitz framework","text":"Sigma = diag(sigma) * C * diag(sigma)","category":"page"},{"location":"Portfolio Optimization/markowitz_framework/","page":"The Markowitz framework","title":"The Markowitz framework","text":"It means that we multiply each column of the correlation matrix by the corresponding standard deviation (diag(sigma) * C) then we multiply each row of the result from this multiplication by the corresponding standard deviation.","category":"page"},{"location":"Portfolio Optimization/markowitz_framework/","page":"The Markowitz framework","title":"The Markowitz framework","text":"To implement this in Julia, we need two functions. First we need to obtain the covariance matrix Sigma based on the correlation matrix C given at the beginning:","category":"page"},{"location":"Portfolio Optimization/markowitz_framework/","page":"The Markowitz framework","title":"The Markowitz framework","text":"function get_cov_from_corr!(portfolio::Portfolio)::Portfolio\n    D = diagm(portfolio.σ) # diagonal matrix of volatiltiy\n    portfolio.Σ = D * portfolio.C * D # multiplying columns and rows of correlation matrix by volatiltiy\n    return portfolio\nend\n\nget_cov_from_corr!(example_1) ","category":"page"},{"location":"Portfolio Optimization/markowitz_framework/","page":"The Markowitz framework","title":"The Markowitz framework","text":"Then, we can obtain the volatility such as:","category":"page"},{"location":"Portfolio Optimization/markowitz_framework/","page":"The Markowitz framework","title":"The Markowitz framework","text":"function get_portfolio_volatility(portfolio::Portfolio)\n    return sqrt(portfolio.x' * portfolio.Σ * portfolio.x)\nend\n\nget_portfolio_volatility(example_1)","category":"page"},{"location":"Portfolio Optimization/markowitz_framework/#Portfolio-simulation","page":"The Markowitz framework","title":"Portfolio simulation","text":"","category":"section"},{"location":"Portfolio Optimization/markowitz_framework/","page":"The Markowitz framework","title":"The Markowitz framework","text":"Base on these information, we will simulate 1000 portfolios thanks to our struct Portfolio and plot the expected returns and volatility of each of them thanks to our previously defined functions. ","category":"page"},{"location":"Portfolio Optimization/markowitz_framework/","page":"The Markowitz framework","title":"The Markowitz framework","text":"First, to simulate 1000 different portfolios (different in terms of weights associated to each asset!), we need to define a function to get random vector of weights x for each portfolio simulated:","category":"page"},{"location":"Portfolio Optimization/markowitz_framework/","page":"The Markowitz framework","title":"The Markowitz framework","text":"using Random # to get random values\n\nRandom.seed!(123) # to fix the \"random simulation\" to something similar for each run.\n\n\nfunction rand_weights(n::Int)\n    k = rand(n) # n random numbers \n    return k / sum(k) # we normalized these random numbers to get weights which sum to 1\nend","category":"page"},{"location":"Portfolio Optimization/markowitz_framework/","page":"The Markowitz framework","title":"The Markowitz framework","text":"Once done, we can now create a function to generate a portfolio with randomly simulated weights:","category":"page"},{"location":"Portfolio Optimization/markowitz_framework/","page":"The Markowitz framework","title":"The Markowitz framework","text":"n = 4 # number of assets\n\nfunction random_portfolio(μ::Vector{Float64}, σ::Vector{Float64}, C::Matrix, n::Int)::Portfolio\n    portfolio_random = Portfolio(μ = μ,\n                                σ = σ,\n                                x = rand_weights(n), # this is the only thing which change\n                                C = C)\n    get_cov_from_corr!(portfolio_random) # to get the covariance matrix\n    return portfolio_random\nend\n\nμ = [0.05, 0.06, 0.08, 0.06] # same expected returns \nσ = [0.15, 0.20, 0.25, 0.30] # same volatility\nC = [\n    1 0.1 0.4 0.5\n    0.1 1 0.7 0.4\n    0.4 0.7 1 0.8\n    0.5 0.4 0.8 1\n    ] # same correlation matrix\n\ntest_portfolio = random_portfolio(μ, σ, C, n)\npretty_table(test_portfolio)","category":"page"},{"location":"Portfolio Optimization/markowitz_framework/","page":"The Markowitz framework","title":"The Markowitz framework","text":"And you obtain a randomly simulated portfolio:","category":"page"},{"location":"Portfolio Optimization/markowitz_framework/","page":"The Markowitz framework","title":"The Markowitz framework","text":"┌──────┬──────┬───────────┐\n│    μ │    σ │         x │\n├──────┼──────┼───────────┤\n│ 0.05 │ 0.15 │  0.194085 │\n│ 0.06 │  0.2 │  0.410517 │\n│ 0.08 │ 0.25 │  0.363097 │\n│ 0.06 │  0.3 │ 0.0323015 │\n└──────┴──────┴───────────┘ ","category":"page"},{"location":"Portfolio Optimization/markowitz_framework/","page":"The Markowitz framework","title":"The Markowitz framework","text":"Now, let's simulate 1000 portfolios, compute the expected returns and volatility for each, and plot it!","category":"page"},{"location":"Portfolio Optimization/markowitz_framework/","page":"The Markowitz framework","title":"The Markowitz framework","text":"using Plots\n\nn_obs = 1000\n\nreturns = zeros(n_obs)\nvolatility = zeros(n_obs)\n\nfor i in 1:n_obs\n    portf = random_portfolio(μ, σ, C, n)\n    returns[i] = get_portfolio_return(portf)\n    volatility[i] = get_portfolio_volatility(portf)\nend\n\nplot(volatility, returns, seriestype = :scatter, label = \"\",\n    xlabel = \"Volatility\", ylabel = \"Expected returns\")","category":"page"},{"location":"Portfolio Optimization/markowitz_framework/","page":"The Markowitz framework","title":"The Markowitz framework","text":"(Image: \"markowitz\")","category":"page"},{"location":"Portfolio Optimization/markowitz_framework/#Optimal-portfolio:-the-Markowitz-QP-formulation","page":"The Markowitz framework","title":"Optimal portfolio: the Markowitz QP formulation","text":"","category":"section"},{"location":"Portfolio Optimization/markowitz_framework/","page":"The Markowitz framework","title":"The Markowitz framework","text":"We have two equivalent optimization problems:","category":"page"},{"location":"Portfolio Optimization/markowitz_framework/","page":"The Markowitz framework","title":"The Markowitz framework","text":"Maximizing the expected return of the portfolio under a volatility constraint (sigma-problem):","category":"page"},{"location":"Portfolio Optimization/markowitz_framework/","page":"The Markowitz framework","title":"The Markowitz framework","text":"beginequation*\nbeginaligned\n textmax\n mu (x)\n textuc\n sigma(x) leq sigma^* \nendaligned\nendequation*","category":"page"},{"location":"Portfolio Optimization/markowitz_framework/","page":"The Markowitz framework","title":"The Markowitz framework","text":"Or minimizing the volatility of the portfolio under a return constraint (mu-problem):","category":"page"},{"location":"Portfolio Optimization/markowitz_framework/","page":"The Markowitz framework","title":"The Markowitz framework","text":"beginequation*\nbeginaligned\n textmin\n sigma(x)\n textuc\n mu(x) geq mu^*\nendaligned\nendequation*","category":"page"},{"location":"Portfolio Optimization/markowitz_framework/","page":"The Markowitz framework","title":"The Markowitz framework","text":"Markowitz transforms the two original non-linear optimization problems into a quadratric optimization problem:","category":"page"},{"location":"Portfolio Optimization/markowitz_framework/","page":"The Markowitz framework","title":"The Markowitz framework","text":"beginequation*\nbeginaligned\n x^*(phi) = \n  textarg max  x^T mu - fracphi2x^T Sigma x\n textuc\n  1^T_n x = 1 \nendaligned\nendequation*","category":"page"},{"location":"Portfolio Optimization/markowitz_framework/","page":"The Markowitz framework","title":"The Markowitz framework","text":"where phi is a risk-aversion parameter:","category":"page"},{"location":"Portfolio Optimization/markowitz_framework/","page":"The Markowitz framework","title":"The Markowitz framework","text":"if phi = 0 we have mu(x^*(0)) = mu^+ (ie. the optimized portfolio is the one that maximizes the expected returns)\nif phi = infty, the optimization problem becomes:","category":"page"},{"location":"Portfolio Optimization/markowitz_framework/","page":"The Markowitz framework","title":"The Markowitz framework","text":"beginequation*\nbeginaligned\n x^*(infty) = \n  textarg min  frac12x^T Sigma x\n textuc\n  1^T_n x = 1 \nendaligned\nendequation*","category":"page"},{"location":"Portfolio Optimization/markowitz_framework/","page":"The Markowitz framework","title":"The Markowitz framework","text":"We have, in this case, sigma(x^*(infty)) = sigma^-. This is the minimum variance (or MV) portfolio (ie. the portfolio that minimizes the volatility).","category":"page"},{"location":"Portfolio Optimization/markowitz_framework/","page":"The Markowitz framework","title":"The Markowitz framework","text":"Let's implement this phi-problem formulation:","category":"page"},{"location":"Portfolio Optimization/markowitz_framework/","page":"The Markowitz framework","title":"The Markowitz framework","text":"using JuMP, COSMO # Packages for optimization\n\nfunction optimal_portfolio_markowitz(μ::Vector{Float64}, Σ::Matrix, ϕ::Float64)::Vector{Float64}\n    n = length(μ) # number of assets\n    model = JuMP.Model(COSMO.Optimizer) # we load COSMO solver\n    @variable(model, x[1:n]) # the optimal weights we want to find\n    @objective(model, Max, x' * μ - ϕ/2 * x' * Σ * x) # the markowitz formulation\n    @constraint(model, ones(n)' * x == 1) # the only constraint we got for now\n    JuMP.optimize!(model) # solve the model\n    x_opt = JuMP.value.(x) # obtain the optimal weights\n    return x_opt\nend\n\nμ = [0.05, 0.06, 0.08, 0.06] # same expected returns\n\nΣ = [\n    0.0225  0.003  0.015   0.0225\n    0.003   0.04   0.035   0.024\n    0.015   0.035  0.0625  0.06\n    0.0225  0.024  0.06    0.09\n] # the covariance matrix","category":"page"},{"location":"Portfolio Optimization/markowitz_framework/","page":"The Markowitz framework","title":"The Markowitz framework","text":"Let's test with a value of phi = 02:","category":"page"},{"location":"Portfolio Optimization/markowitz_framework/","page":"The Markowitz framework","title":"The Markowitz framework","text":"x_opt = optimal_portfolio_markowitz(μ, Σ, 0.2)","category":"page"},{"location":"Portfolio Optimization/markowitz_framework/","page":"The Markowitz framework","title":"The Markowitz framework","text":"We get:","category":"page"},{"location":"Portfolio Optimization/markowitz_framework/","page":"The Markowitz framework","title":"The Markowitz framework","text":" -0.33746115671814536\n -3.034877788599787\n  8.06224201103845\n -3.6899030657205145","category":"page"},{"location":"Portfolio Optimization/markowitz_framework/","page":"The Markowitz framework","title":"The Markowitz framework","text":"And we have the following expected returns","category":"page"},{"location":"Portfolio Optimization/markowitz_framework/","page":"The Markowitz framework","title":"The Markowitz framework","text":"portf = Portfolio(μ = μ, σ = σ, C = C, Σ = Σ, x = x_opt)\nreturns = get_portfolio_return(portf)","category":"page"},{"location":"Portfolio Optimization/markowitz_framework/","page":"The Markowitz framework","title":"The Markowitz framework","text":"0.2246194517879506","category":"page"},{"location":"Portfolio Optimization/markowitz_framework/","page":"The Markowitz framework","title":"The Markowitz framework","text":"and volatility:","category":"page"},{"location":"Portfolio Optimization/markowitz_framework/","page":"The Markowitz framework","title":"The Markowitz framework","text":"volatility = get_portfolio_volatility(portf)","category":"page"},{"location":"Portfolio Optimization/markowitz_framework/","page":"The Markowitz framework","title":"The Markowitz framework","text":"0.9456799462474924","category":"page"},{"location":"Portfolio Optimization/markowitz_framework/","page":"The Markowitz framework","title":"The Markowitz framework","text":"Let's simulate simulate this for several phi values and plot the resulting efficient frontier:","category":"page"},{"location":"Portfolio Optimization/markowitz_framework/","page":"The Markowitz framework","title":"The Markowitz framework","text":"phis = [i for i in 1:0.1:500]\n\nreturns = zeros(length(phis))\nvolatility = zeros(length(phis))\nfor i in 1:length(phis)\n    x = optimal_portfolio_markowitz(μ, Σ, phis[i])\n    portf = Portfolio(μ = μ, σ = σ, C = C, Σ = Σ, x = x)\n    returns[i] = get_portfolio_return(portf)\n    volatility[i] = get_portfolio_volatility(portf)\nend\n\n\nplot(volatility, returns, seriestype = :line, label = \"\",\n    xlabel = \"Volatility\", ylabel = \"Expected returns\")","category":"page"},{"location":"Portfolio Optimization/markowitz_framework/","page":"The Markowitz framework","title":"The Markowitz framework","text":"(Image: \"efficientfrontier1\")","category":"page"},{"location":"Portfolio Optimization/markowitz_framework/#Solving-\\mu-and-\\gamma-problems","page":"The Markowitz framework","title":"Solving mu- and gamma- problems","text":"","category":"section"},{"location":"Portfolio Optimization/markowitz_framework/","page":"The Markowitz framework","title":"The Markowitz framework","text":"Solving the mu-problem or the sigma-problem is equivalent to finding the optimal value of phi such that:","category":"page"},{"location":"Portfolio Optimization/markowitz_framework/","page":"The Markowitz framework","title":"The Markowitz framework","text":"mu(x^*(phi))=mu^*","category":"page"},{"location":"Portfolio Optimization/markowitz_framework/","page":"The Markowitz framework","title":"The Markowitz framework","text":"or:","category":"page"},{"location":"Portfolio Optimization/markowitz_framework/","page":"The Markowitz framework","title":"The Markowitz framework","text":"sigma(x^*(phi))=sigma^*","category":"page"},{"location":"Portfolio Optimization/markowitz_framework/","page":"The Markowitz framework","title":"The Markowitz framework","text":"We know that:","category":"page"},{"location":"Portfolio Optimization/markowitz_framework/","page":"The Markowitz framework","title":"The Markowitz framework","text":"the functions mu(x^*(phi)) and sigma(x^*(phi)) are decreasing with respect to phi\nthe functions mu(x^*(phi)) and sigma(x^*(phi)) are bounded","category":"page"},{"location":"Portfolio Optimization/markowitz_framework/","page":"The Markowitz framework","title":"The Markowitz framework","text":"Then, we can find the optimal value of phi (ie. the value of phi to attain a specific target of sigma^* or mu^*) using the bisection algorithm (Newton-Raphson algorithm).","category":"page"},{"location":"ESG Investing/qp_problem_for_enhanced_esg/#Passive-Management-and-ESG-Scores","page":"QP Problem for Enhanced ESG Score","title":"Passive Management and ESG Scores","text":"","category":"section"},{"location":"ESG Investing/qp_problem_for_tilting/#QP-Problem-for-Tilted-Portfolios","page":"QP Problem for Tilting","title":"QP Problem for Tilted Portfolios","text":"","category":"section"},{"location":"ESG Investing/qp_problem_for_tilting/#Portfolio-ESG-Score","page":"QP Problem for Tilting","title":"Portfolio ESG Score","text":"","category":"section"},{"location":"ESG Investing/qp_problem_for_tilting/","page":"QP Problem for Tilting","title":"QP Problem for Tilting","text":"Let's first create a struct Benchmark to store the main informations we have:","category":"page"},{"location":"ESG Investing/qp_problem_for_tilting/","page":"QP Problem for Tilting","title":"QP Problem for Tilting","text":"Base.@kwdef mutable struct Benchmark\n    μ::Vector{Float64} # Expected returns \n    b::Vector{Float64} # benchmark weights\n    s::Vector{Float64} # ESG Score\n    Σ::Matrix # Covariance Matrix\nend\n\nΣ = [ 0.1536  0.006  0.0108  0.0156  0.024\n0.006   0.17   0.018   0.026   0.04\n0.0108  0.018  0.1324  0.0468  0.072\n0.0156  0.026  0.0468  0.1776  0.104\n0.024   0.04   0.072   0.104   0.28]\n\nour_benchmark = Benchmark(μ = [0.03,0.04,0.05,0.07,0.1],\n                        b = [0.2, 0.2, 0.2, 0.2, 0.2],\n                        s= [1.1,2.7,-0.9,-2.2,0.4], \n                        Σ = Σ)","category":"page"},{"location":"ESG Investing/qp_problem_for_tilting/","page":"QP Problem for Tilting","title":"QP Problem for Tilting","text":"Given the ESG scores and the respective weights for each issuer, how to compute the benchmark ESG score?","category":"page"},{"location":"ESG Investing/qp_problem_for_tilting/","page":"QP Problem for Tilting","title":"QP Problem for Tilting","text":"We have:","category":"page"},{"location":"ESG Investing/qp_problem_for_tilting/","page":"QP Problem for Tilting","title":"QP Problem for Tilting","text":"S^esg(b) = sum^5_i=1b_iS^esg_i","category":"page"},{"location":"ESG Investing/qp_problem_for_tilting/","page":"QP Problem for Tilting","title":"QP Problem for Tilting","text":"= b^TS^esg","category":"page"},{"location":"ESG Investing/qp_problem_for_tilting/","page":"QP Problem for Tilting","title":"QP Problem for Tilting","text":"Let's implement it in Julia:","category":"page"},{"location":"ESG Investing/qp_problem_for_tilting/","page":"QP Problem for Tilting","title":"QP Problem for Tilting","text":"function get_benchmark_score(bench::Benchmark)::Float64\n    return round(bench.b' * bench.s; digits= 2)\nend\n\nget_benchmark_score(our_benchmark) ","category":"page"},{"location":"ESG Investing/qp_problem_for_tilting/","page":"QP Problem for Tilting","title":"QP Problem for Tilting","text":"and the result is:","category":"page"},{"location":"ESG Investing/qp_problem_for_tilting/","page":"QP Problem for Tilting","title":"QP Problem for Tilting","text":"0.22","category":"page"},{"location":"ESG Investing/qp_problem_for_tilting/#Excess-Expected-Returns-and-Tracking-Error-Volatility","page":"QP Problem for Tilting","title":"Excess Expected Returns and Tracking Error Volatility","text":"","category":"section"},{"location":"ESG Investing/qp_problem_for_tilting/","page":"QP Problem for Tilting","title":"QP Problem for Tilting","text":"Having the previous benchmark, let's assume a portfolio with the same issuers than the benchmark, but different weights x.  How can we compare the relative performance of the tilted portfolio compared to the benchmark? ","category":"page"},{"location":"ESG Investing/qp_problem_for_tilting/","page":"QP Problem for Tilting","title":"QP Problem for Tilting","text":"We will compute first the excess expected returns:","category":"page"},{"location":"ESG Investing/qp_problem_for_tilting/","page":"QP Problem for Tilting","title":"QP Problem for Tilting","text":"mu(xb) = (x - b)^T mu","category":"page"},{"location":"ESG Investing/qp_problem_for_tilting/","page":"QP Problem for Tilting","title":"QP Problem for Tilting","text":"and then the tracking error volatility:","category":"page"},{"location":"ESG Investing/qp_problem_for_tilting/","page":"QP Problem for Tilting","title":"QP Problem for Tilting","text":"sigma(x b) = sqrt(x-b)^TSigma(x-b)","category":"page"},{"location":"ESG Investing/qp_problem_for_tilting/","page":"QP Problem for Tilting","title":"QP Problem for Tilting","text":"Let's implement this:","category":"page"},{"location":"ESG Investing/qp_problem_for_tilting/","page":"QP Problem for Tilting","title":"QP Problem for Tilting","text":"\nBase.@kwdef mutable struct TiltedPortfolio\n    x::Vector{Float64} # Optimal weights\nend\n\nportfolio = TiltedPortfolio(x = [0.1, 0.1, 0.3, 0.3, 0.2])\n\n\nfunction get_excess_returns(portfolio::TiltedPortfolio, bench::Benchmark)::Float64 \n    return round((portfolio.x - bench.b)' * bench.μ;digits = 5)\nend\n\n\nfunction tracking_error_volatility(portfolio::TiltedPortfolio, bench::Benchmark)::Float64\n    return sqrt((portfolio.x - bench.b)' * bench.Σ * (portfolio.x - bench.b))\nend","category":"page"},{"location":"ESG Investing/qp_problem_for_tilting/","page":"QP Problem for Tilting","title":"QP Problem for Tilting","text":"Let's find first the excess expected returns:","category":"page"},{"location":"ESG Investing/qp_problem_for_tilting/","page":"QP Problem for Tilting","title":"QP Problem for Tilting","text":"get_excess_returns(portfolio, our_benchmark)","category":"page"},{"location":"ESG Investing/qp_problem_for_tilting/","page":"QP Problem for Tilting","title":"QP Problem for Tilting","text":"which returns:","category":"page"},{"location":"ESG Investing/qp_problem_for_tilting/","page":"QP Problem for Tilting","title":"QP Problem for Tilting","text":"0.005","category":"page"},{"location":"ESG Investing/qp_problem_for_tilting/","page":"QP Problem for Tilting","title":"QP Problem for Tilting","text":"and then the tracking error volatiltiy:","category":"page"},{"location":"ESG Investing/qp_problem_for_tilting/","page":"QP Problem for Tilting","title":"QP Problem for Tilting","text":"tracking_error_volatility(portfolio, our_benchmark)","category":"page"},{"location":"ESG Investing/qp_problem_for_tilting/","page":"QP Problem for Tilting","title":"QP Problem for Tilting","text":"which gives:","category":"page"},{"location":"ESG Investing/qp_problem_for_tilting/","page":"QP Problem for Tilting","title":"QP Problem for Tilting","text":"0.07735631842325487","category":"page"},{"location":"ESG Investing/qp_problem_for_tilting/#Standard-QP-Problem","page":"QP Problem for Tilting","title":"Standard QP Problem","text":"","category":"section"},{"location":"ESG Investing/qp_problem_for_tilting/","page":"QP Problem for Tilting","title":"QP Problem for Tilting","text":"Recall that the formulation of a standard QP problem is:","category":"page"},{"location":"ESG Investing/qp_problem_for_tilting/","page":"QP Problem for Tilting","title":"QP Problem for Tilting","text":"beginequation*\nbeginaligned\n x^* = \n  textarg min  frac12x^TQx-x^TR\n textsubject to\n  Ax = B \n Cx leq D \n x^- leq x leq x^+\nendaligned\nendequation*","category":"page"},{"location":"ESG Investing/qp_problem_for_tilting/","page":"QP Problem for Tilting","title":"QP Problem for Tilting","text":"Let's assume an example where we would like to tilt the benchmark b in order to improve its expected return. We have a modified gamma problem where gamma is the risk aversion parameter. What we want in this exercise is:","category":"page"},{"location":"ESG Investing/qp_problem_for_tilting/","page":"QP Problem for Tilting","title":"QP Problem for Tilting","text":"enhance the excess expected return compared to the benchmark: ","category":"page"},{"location":"ESG Investing/qp_problem_for_tilting/","page":"QP Problem for Tilting","title":"QP Problem for Tilting","text":"mu(xb)","category":"page"},{"location":"ESG Investing/qp_problem_for_tilting/","page":"QP Problem for Tilting","title":"QP Problem for Tilting","text":"and minimize the tracking error volatility relative to the benchmark:","category":"page"},{"location":"ESG Investing/qp_problem_for_tilting/","page":"QP Problem for Tilting","title":"QP Problem for Tilting","text":"sigma^2(x b)","category":"page"},{"location":"ESG Investing/qp_problem_for_tilting/#Modified-Objective-Function","page":"QP Problem for Tilting","title":"Modified Objective Function","text":"","category":"section"},{"location":"ESG Investing/qp_problem_for_tilting/","page":"QP Problem for Tilting","title":"QP Problem for Tilting","text":"The initial objective function:","category":"page"},{"location":"ESG Investing/qp_problem_for_tilting/","page":"QP Problem for Tilting","title":"QP Problem for Tilting","text":"x^* = textarg min frac12x^TQx-x^TR","category":"page"},{"location":"ESG Investing/qp_problem_for_tilting/","page":"QP Problem for Tilting","title":"QP Problem for Tilting","text":"becomes: ","category":"page"},{"location":"ESG Investing/qp_problem_for_tilting/","page":"QP Problem for Tilting","title":"QP Problem for Tilting","text":"x^* =  textarg min frac12 sigma^2(x b) - mu(xb)","category":"page"},{"location":"ESG Investing/qp_problem_for_tilting/","page":"QP Problem for Tilting","title":"QP Problem for Tilting","text":"Since we want to formulate the gamma-problem of portfolio optimization, it becomes:","category":"page"},{"location":"ESG Investing/qp_problem_for_tilting/","page":"QP Problem for Tilting","title":"QP Problem for Tilting","text":"x^*(gamma) = textarg min frac12 sigma^2(x b) - gammamu(xb)","category":"page"},{"location":"ESG Investing/qp_problem_for_tilting/","page":"QP Problem for Tilting","title":"QP Problem for Tilting","text":"Finally, since sigma^2(xb)=(x-b)^T Sigma (x-b) and mu(xb) = (x-b)^T mu, we have the QP objective function:","category":"page"},{"location":"ESG Investing/qp_problem_for_tilting/","page":"QP Problem for Tilting","title":"QP Problem for Tilting","text":"x^*(gamma) = textarg min frac12 x^T Sigma x - x^T (gamma mu + Sigma b)","category":"page"},{"location":"ESG Investing/qp_problem_for_tilting/#Modified-Constraints","page":"QP Problem for Tilting","title":"Modified Constraints","text":"","category":"section"},{"location":"ESG Investing/qp_problem_for_tilting/","page":"QP Problem for Tilting","title":"QP Problem for Tilting","text":"Let's now reformulate the initial constraints.  We first had in the initial QP problem:","category":"page"},{"location":"ESG Investing/qp_problem_for_tilting/","page":"QP Problem for Tilting","title":"QP Problem for Tilting","text":"Ax = B","category":"page"},{"location":"ESG Investing/qp_problem_for_tilting/","page":"QP Problem for Tilting","title":"QP Problem for Tilting","text":"which will become:","category":"page"},{"location":"ESG Investing/qp_problem_for_tilting/","page":"QP Problem for Tilting","title":"QP Problem for Tilting","text":"1^T_nx = 1","category":"page"},{"location":"ESG Investing/qp_problem_for_tilting/","page":"QP Problem for Tilting","title":"QP Problem for Tilting","text":"(i.e. the sum of the weights x_i must sum to one)","category":"page"},{"location":"ESG Investing/qp_problem_for_tilting/","page":"QP Problem for Tilting","title":"QP Problem for Tilting","text":"We then had:","category":"page"},{"location":"ESG Investing/qp_problem_for_tilting/","page":"QP Problem for Tilting","title":"QP Problem for Tilting","text":"x^- leq x leq x^+","category":"page"},{"location":"ESG Investing/qp_problem_for_tilting/","page":"QP Problem for Tilting","title":"QP Problem for Tilting","text":"Which becomes:","category":"page"},{"location":"ESG Investing/qp_problem_for_tilting/","page":"QP Problem for Tilting","title":"QP Problem for Tilting","text":"0_n leq x leq 1_n","category":"page"},{"location":"ESG Investing/qp_problem_for_tilting/","page":"QP Problem for Tilting","title":"QP Problem for Tilting","text":"(i.e. the weights x_i must be between 0 and 1)","category":"page"},{"location":"ESG Investing/qp_problem_for_tilting/","page":"QP Problem for Tilting","title":"QP Problem for Tilting","text":"Let's implement this in Julia:","category":"page"},{"location":"ESG Investing/qp_problem_for_tilting/","page":"QP Problem for Tilting","title":"QP Problem for Tilting","text":"using JuMP, COSMO # for the optimization\n\n\n# tilt the benchmark according to gamma\nfunction portfolio_tilting(bench::Benchmark, γ::Float64)::TiltedPortfolio\n    n = length(bench.μ) # number of assets\n    model = JuMP.Model(COSMO.Optimizer)\n    # the optimal weights we want to find\n    @variable(model, x[1:n])\n    @objective(model, Min, 1/2 * x' * Σ * x - x' * (γ * bench.μ + bench.Σ * bench.b))\n    @constraint(model, zeros(n) .<= x .<= ones(n))\n    @constraint(model, ones(n)' * x == 1)\n    JuMP.optimize!(model)\n    portfolio = TiltedPortfolio(x = JuMP.value.(x))\n    return portfolio\nend\n\n\n# simulate for gammas between 0 and 10\nusing Plots\ngammas = [i for i in 0.0:1:10.0]\nexcess_returns = zeros(length(gammas))\nexcess_te = zeros(length(gammas))\nesg_scores = zeros(length(gammas))\n\nfor i in 1:length(gammas)\n    new_portfolio = portfolio_tilting(our_benchmark, gammas[i])\n    excess_returns[i] = get_excess_returns(new_portfolio, our_benchmark)\n    excess_te[i] = tracking_error_volatility(new_portfolio, our_benchmark)\n    esg_scores[i] = get_portfolio_score(new_portfolio, our_benchmark)\nend\n\n\nplot(excess_te, excess_returns, xlabel = \"Tracking error volatility\",\n                                ylabel = \"Excess expected returns\",\n                                label = \"\")\n\n\nplot(excess_te, esg_scores, xlabel = \"Tracking error volatility\",\nylabel = \"ESG score\", label = \"\")","category":"page"},{"location":"ESG Investing/qp_problem_for_tilting/","page":"QP Problem for Tilting","title":"QP Problem for Tilting","text":"(Image: \"tilt_1\") (Image: \"tilt_2\")","category":"page"},{"location":"#Julia-for-Sustainable-Finance","page":"Home","title":"Julia for Sustainable Finance","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The objective of this website is to explain how to program various models in Julia. Examples and structure are based on Thierry Roncalli's lecture.","category":"page"},{"location":"Introduction to Optimization/bisection_algorithm/#Bisection-Algorithm","page":"Bisection Algorithm","title":"Bisection Algorithm","text":"","category":"section"},{"location":"Introduction to Optimization/bisection_algorithm/","page":"Bisection Algorithm","title":"Bisection Algorithm","text":"Bisection method is a root-finding method that applies to any continuous functions for which one knows two values with opposite signs.","category":"page"},{"location":"Introduction to Optimization/bisection_algorithm/","page":"Bisection Algorithm","title":"Bisection Algorithm","text":"The method consists of repeatedly bisecting the interval defined by these values and then selecting the subinterval in which the function changes sign, and therefore must contain a root. ","category":"page"},{"location":"Introduction to Optimization/bisection_algorithm/#Iteration-tasks","page":"Bisection Algorithm","title":"Iteration tasks","text":"","category":"section"},{"location":"Introduction to Optimization/bisection_algorithm/","page":"Bisection Algorithm","title":"Bisection Algorithm","text":"The input for the method is a continuous function f, an interval ab, and the function values f(a) and f(b).","category":"page"},{"location":"Introduction to Optimization/bisection_algorithm/","page":"Bisection Algorithm","title":"Bisection Algorithm","text":"The function values are of opposite sign (there is at least one zero crossing whitin the interval). ","category":"page"},{"location":"Introduction to Optimization/bisection_algorithm/","page":"Bisection Algorithm","title":"Bisection Algorithm","text":"Each iteration perfoms these steps:","category":"page"},{"location":"Introduction to Optimization/bisection_algorithm/","page":"Bisection Algorithm","title":"Bisection Algorithm","text":"Calculate c, the midpoint of the interval, c = fraca+b2.\nCalculate the function value at the midpoint, f(c).\nIf converge is satisfactory (that is, c-a is sufficiently small, or f(c) is sufficiently small), return c and stop iterating.\nExamine the sign of f(c) and replace either (a f(a)) or (bf(b)) with (c f(c)) so that there is a zero crossing within the new interval.","category":"page"},{"location":"Introduction to Optimization/bisection_algorithm/","page":"Bisection Algorithm","title":"Bisection Algorithm","text":"Example 1:","category":"page"},{"location":"Introduction to Optimization/bisection_algorithm/","page":"Bisection Algorithm","title":"Bisection Algorithm","text":"Let's start with an easy problem: Consider f(x) = (x-1)^2 - 4  We know f(3) = 0; hence x = 3 is a root of f(x). ","category":"page"},{"location":"Introduction to Optimization/bisection_algorithm/","page":"Bisection Algorithm","title":"Bisection Algorithm","text":"Let's implement it in Julia:","category":"page"},{"location":"Introduction to Optimization/bisection_algorithm/","page":"Bisection Algorithm","title":"Bisection Algorithm","text":"function f(x)\n    return (x-1)^2 - 4 \nend\n\n\na = 0; b = 5; # The interval \ndelta = 1e-9; # the convergence threshold\n\n# Set a max iteration so we don't get stuck in the loop forever \nMAX_ITER = 100;\nN = 1; # counter for iteration \n\nwhile N < MAX_ITER\n    # Step 1: calculate c, the midpoint of the interval \n    c = (a + b) / 2;\n    # Step 2: calculate the function value at the midpoint c\n    fc = f(c);\n    # Step 3: if converge is satisfactory (c-a sufficiently small or absolute function value sufficiently small), return C and stop\n    if abs(c-a) < delta || abs(fc) < delta \n        println(\"Converged at iteration: N = \", N)\n        break \n    end\n    N += 1\n    # Step 4: examine the sign of f(c) and replace either (a, f(a)) or (b, f(b)) with (c, f(c)) so that there is a zero crossing the new interval\n    if sign(fc) == sign(f(a)) # update the search interval \n        a = c;\n    else\n        b = c;\n    end\nend\n\nc = (a + b) / 2\nprint(\"c:\", c, \"\\n\")\nprint(\"f(c):\", f(c), \"\\n\")\n\n","category":"page"}]
}
