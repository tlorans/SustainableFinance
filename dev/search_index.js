var documenterSearchIndex = {"docs":
[{"location":"ESG_Scoring/scoring_system/#ESG-Scoring","page":"Scoring System","title":"ESG Scoring","text":"","category":"section"},{"location":"ESG_Scoring/scoring_system/","page":"Scoring System","title":"Scoring System","text":"Most of ESG scoring systems are based on scoring trees. \nRaw data are normalised in order to obtain features X_1X_m\nFeatures X_1X_m are aggregated to obtain sub-scores s_1s_n:","category":"page"},{"location":"ESG_Scoring/scoring_system/","page":"Scoring System","title":"Scoring System","text":"s_i = sum_j=1^m omega_ij^(1)X_j","category":"page"},{"location":"ESG_Scoring/scoring_system/","page":"Scoring System","title":"Scoring System","text":"Sub-scores s_1s_n are aggregated to obtain the final score s:","category":"page"},{"location":"ESG_Scoring/scoring_system/","page":"Scoring System","title":"Scoring System","text":"s_i = sum_i=1^n omega_i^(2)s_i","category":"page"},{"location":"ESG_Scoring/scoring_system/","page":"Scoring System","title":"Scoring System","text":"This two-level structure can be extended to multi-level tree structures.","category":"page"},{"location":"ESG_Scoring/scoring_system/","page":"Scoring System","title":"Scoring System","text":"Let's implement the first stage of our scoring system.","category":"page"},{"location":"ESG_Scoring/scoring_system/","page":"Scoring System","title":"Scoring System","text":"First, we create a struct Variable, with two examples variables:","category":"page"},{"location":"ESG_Scoring/scoring_system/","page":"Scoring System","title":"Scoring System","text":"Base.@kwdef mutable struct Variable\n    X::Vector{Float64}\n    name::String \nend\n\nX₁ = Variable(X = [94.0, 38.6, 30.6, 74.4, 97.1, 57.1, 132.4, 92.5, 64.9], name = \"X₁\") \n\nX₂ = Variable(X = [-0.03, -0.0550, 0.056, -0.013, -0.168, -0.035, 0.0850, -0.0910, -0.0460], name = \"X₂\")","category":"page"},{"location":"ESG_Scoring/scoring_system/","page":"Scoring System","title":"Scoring System","text":"Let's also extend the functionality of PrettyTables.jl to support our new Variable struct:","category":"page"},{"location":"ESG_Scoring/scoring_system/","page":"Scoring System","title":"Scoring System","text":"using PrettyTables\n\n\nfunction PrettyTables.pretty_table(X::Vector{Variable})\n    x = reduce(hcat,[X[i].X for i in eachindex(X)])\n    X_names = reduce(vcat,[X[i].name for i in eachindex(X)])\n    return pretty_table(x, header = X_names)\nend\n\npretty_table([X₁, X₂])","category":"page"},{"location":"ESG_Scoring/scoring_system/","page":"Scoring System","title":"Scoring System","text":"This prints a nice table in the REPL:","category":"page"},{"location":"ESG_Scoring/scoring_system/","page":"Scoring System","title":"Scoring System","text":"┌───────┬────────┐\n│    X₁ │     X₂ │\n├───────┼────────┤\n│  30.6 │ -0.168 │\n│  38.6 │ -0.091 │\n│  57.1 │ -0.055 │\n│  64.9 │ -0.046 │\n│  74.4 │ -0.035 │\n│  92.5 │  -0.03 │\n│  94.0 │ -0.013 │\n│  97.1 │  0.056 │\n│ 132.4 │  0.085 │\n└───────┴────────┘","category":"page"},{"location":"ESG_Scoring/scoring_system/","page":"Scoring System","title":"Scoring System","text":"Now, the question is: how can we aggregate X_1 and X_2 to create a synthetic score? ","category":"page"},{"location":"ESG_Scoring/scoring_system/","page":"Scoring System","title":"Scoring System","text":"We need to normalize the features X_1  X_n!","category":"page"},{"location":"ESG_Scoring/scoring_system/#Normalizing-Scores","page":"Scoring System","title":"Normalizing Scores","text":"","category":"section"},{"location":"ESG_Scoring/scoring_system/","page":"Scoring System","title":"Scoring System","text":"Once raw data have been normalized in order to facilitate the comparison (ie. absolute carbon emissions amount transformed to carbon intensity for example), resulting features X_1  X_m need to be normalized to facilitate the aggregation process.","category":"page"},{"location":"ESG_Scoring/scoring_system/","page":"Scoring System","title":"Scoring System","text":"Several normalization approches exist:","category":"page"},{"location":"ESG_Scoring/scoring_system/","page":"Scoring System","title":"Scoring System","text":"q-score normalization:\n0-1 normalization: q_i in 01\n0-10 normalization: q_i in 010\n0-100 normalization: q_i in 0100","category":"page"},{"location":"ESG_Scoring/scoring_system/","page":"Scoring System","title":"Scoring System","text":"q_i = hat F(x_i)","category":"page"},{"location":"ESG_Scoring/scoring_system/","page":"Scoring System","title":"Scoring System","text":"Where hat F is the empirical probability distribution.","category":"page"},{"location":"ESG_Scoring/scoring_system/","page":"Scoring System","title":"Scoring System","text":"z-score normalization:","category":"page"},{"location":"ESG_Scoring/scoring_system/","page":"Scoring System","title":"Scoring System","text":"z_i = fracx_i - hatmu(X)hatsigma(X)","category":"page"},{"location":"ESG_Scoring/scoring_system/","page":"Scoring System","title":"Scoring System","text":"To do so, let's implement a Score struct and a ScoringSystem struct. ","category":"page"},{"location":"ESG_Scoring/scoring_system/","page":"Scoring System","title":"Scoring System","text":"Base.@kwdef mutable struct Score\n    S::Vector{Float64}} # resulting score\n    name::String\nend\n\n\nBase.@kwdef mutable struct ScoringSystem\n    X::Vector{Variable}\n    S::Union{Nothing, Vector{Score}} = nothing # the vector of scores\n    ω::Union{Nothing, Vector{Float64}} = nothing # the vector of weights\nend\n\nour_scoring = ScoringSystem(X = [X₁,X₂])","category":"page"},{"location":"ESG_Scoring/scoring_system/","page":"Scoring System","title":"Scoring System","text":"The purpose of the struct Score is to facilitate the interface between our Variable, our future functions for normalization, and the result (the Score). The purpose of the ScoringSystem struct is to regroup / organize our little scoring system.","category":"page"},{"location":"ESG_Scoring/scoring_system/#q-score","page":"Scoring System","title":"q-score","text":"","category":"section"},{"location":"ESG_Scoring/scoring_system/","page":"Scoring System","title":"Scoring System","text":"Let x_1  x_n be the sample. We have:","category":"page"},{"location":"ESG_Scoring/scoring_system/","page":"Scoring System","title":"Scoring System","text":"q_i = hatF(x_i) = Pr(X leq x_i) = frac(x_j leq x_i)n_q","category":"page"},{"location":"ESG_Scoring/scoring_system/","page":"Scoring System","title":"Scoring System","text":"We can use two normalization factors:","category":"page"},{"location":"ESG_Scoring/scoring_system/","page":"Scoring System","title":"Scoring System","text":"n_q = n\nn_q = n + 1","category":"page"},{"location":"ESG_Scoring/scoring_system/","page":"Scoring System","title":"Scoring System","text":"Let's implement this in Julia:","category":"page"},{"location":"ESG_Scoring/scoring_system/","page":"Scoring System","title":"Scoring System","text":"using Plots # to print the ecdf\n\nfunction q_score(X::Variable; scale = 100, get_plot = true)::Score \n    # the number of observations\n    n = length(X.X)\n    # we normalize the number of observations less or equal to each observation by n + 1 (the second normalization factor)\n    q = [length(filter(x -> x <= i, X.X))/(n+1) for i in X.X] .* scale\n    s = Score(S = q, name = string(\"q-score \",X.name))\n    # we print the ecdf of the variable to get a sense of q-score normalization\n    if get_plot\n        display(plot(sort(X.X), (1:n)./n * 100, \n            xlabel = X.name, ylabel = s.name,\n            title = \"q-score normalization\", label = \"\"))\n    end\n    return s\nend\n\n# just the vector version of the function\nfunction q_score(X::Vector{Variable}; scale = 100, get_plot = true)::Vector{Score}\n    s = []\n    for i in eachindex(X)\n        push!(s, q_score(X[i]; scale, get_plot))\n    end \n    return s \nend\n\n# and finally the version applied to our scoring system\nfunction q_score!(s::ScoringSystem; scale = 100, get_plot = true)::ScoringSystem\n    s.S = q_score(s.X; scale, get_plot)\n    return s\nend\n\nq_score!(our_scoring)","category":"page"},{"location":"ESG_Scoring/scoring_system/","page":"Scoring System","title":"Scoring System","text":"The resulting scoring functions looks like the graphs below: (Image: \"ecdf\") (Image: \"ecdf\")","category":"page"},{"location":"ESG_Scoring/scoring_system/","page":"Scoring System","title":"Scoring System","text":"Now let's again extend the PrettyTables.jl functionality to be applied on our ScoringSystem:","category":"page"},{"location":"ESG_Scoring/scoring_system/","page":"Scoring System","title":"Scoring System","text":"\nfunction PrettyTables.pretty_table(s::ScoringSystem)\n    X = reduce(hcat,[s.X[i].X for i in eachindex(s.X)])\n    S = reduce(hcat,[s.S[i].S for i in eachindex(s.S)])\n    X_names = reduce(vcat,[s.X[i].name for i in eachindex(s.X)])\n    S_names = reduce(vcat,[s.S[i].name for i in eachindex(s.S)])\n    return pretty_table(hcat(X,S), header = vcat(X_names, S_names))\nend\n\npretty_table(our_scoring)","category":"page"},{"location":"ESG_Scoring/scoring_system/","page":"Scoring System","title":"Scoring System","text":"We get the following table:","category":"page"},{"location":"ESG_Scoring/scoring_system/","page":"Scoring System","title":"Scoring System","text":"┌───────┬────────┬────────────┬────────────┐\n│    X₁ │     X₂ │ q-score X₁ │ q-score X₂ │\n├───────┼────────┼────────────┼────────────┤\n│  94.0 │  -0.03 │       70.0 │       60.0 │\n│  38.6 │ -0.055 │       20.0 │       30.0 │\n│  30.6 │  0.056 │       10.0 │       80.0 │\n│  74.4 │ -0.013 │       50.0 │       70.0 │\n│  97.1 │ -0.168 │       80.0 │       10.0 │\n│  57.1 │ -0.035 │       30.0 │       50.0 │\n│ 132.4 │  0.085 │       90.0 │       90.0 │\n│  92.5 │ -0.091 │       60.0 │       20.0 │\n│  64.9 │ -0.046 │       40.0 │       40.0 │\n└───────┴────────┴────────────┴────────────┘","category":"page"},{"location":"ESG_Scoring/scoring_system/#z-score","page":"Scoring System","title":"z-score","text":"","category":"section"},{"location":"ESG_Scoring/scoring_system/","page":"Scoring System","title":"Scoring System","text":"Another normalization method can be the z-score:","category":"page"},{"location":"ESG_Scoring/scoring_system/","page":"Scoring System","title":"Scoring System","text":"using Statistics # to load the mean and std functions\n\n# z-score normalization for a unique variable\nfunction z_score(X::Variable; get_plot = true)::Score \n    μ = mean(X.X)\n    σ = std(X.X)\n    z = [(i - μ) / σ for i in X.X]\n    s = Score(S = z, name = string(\"z-score \",X.name))\n    if get_plot\n        display(plot(sort(X.X), sort(s.S), \n            xlabel = X.name, ylabel = s.name,\n            title = \"z-score normalization\", label = \"\"))\n    end\n    return s\nend\n\n# vector version\nfunction z_score(X::Vector{Variable}; get_plot = true)::Vector{Score}\n    s = []\n    for i in eachindex(X)\n        push!(s, z_score(X[i]; get_plot))\n    end \n    return s \nend\n\n# version to be applied to our scoring system\nfunction z_score!(s::ScoringSystem; get_plot = true)::ScoringSystem\n    s.S = z_score(s.X; get_plot)\n    return s\nend\n\nz_score!(our_scoring)","category":"page"},{"location":"ESG_Scoring/scoring_system/","page":"Scoring System","title":"Scoring System","text":"(Image: \"z-score\") (Image: \"z-score\")","category":"page"},{"location":"ESG_Scoring/scoring_system/","page":"Scoring System","title":"Scoring System","text":"┌───────┬────────┬────────────┬────────────┐\n│    X₁ │     X₂ │ z-score X₁ │ z-score X₂ │\n├───────┼────────┼────────────┼────────────┤\n│  94.0 │  -0.03 │   0.571788 │  0.0402241 │\n│  38.6 │ -0.055 │   -1.16236 │  -0.294977 │\n│  30.6 │  0.056 │   -1.41277 │    1.19331 │\n│  74.4 │ -0.013 │ -0.0417363 │   0.268161 │\n│  97.1 │ -0.168 │   0.668825 │   -1.81008 │\n│  57.1 │ -0.035 │  -0.583265 │ -0.0268161 │\n│ 132.4 │  0.085 │    1.77379 │    1.58215 │\n│  92.5 │ -0.091 │   0.524834 │  -0.777666 │\n│  64.9 │ -0.046 │  -0.339108 │  -0.174304 │\n└───────┴────────┴────────────┴────────────┘","category":"page"},{"location":"ESG_Scoring/scoring_system/#Score-Aggregation","page":"Scoring System","title":"Score Aggregation","text":"","category":"section"},{"location":"ESG_Scoring/scoring_system/","page":"Scoring System","title":"Scoring System","text":"Now that we have normalized our scores, let's compute the final scores, based on a weighting set such as omega_1 = 03 and omega_2 = 07:","category":"page"},{"location":"#Julia-for-Sustainable-Finance","page":"Home","title":"Julia for Sustainable Finance","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The objective of this website is to explain how to program various models in Julia. Examples and structure are based on Thierry Roncalli's lecture.","category":"page"}]
}
